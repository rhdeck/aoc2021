const data18 = `[6,[8,5]]
[[2,[[0,2],4]],[1,[8,0]]]
[[[9,8],[[0,5],[9,3]]],[8,[[1,1],[2,6]]]]
[[5,[[5,7],[9,4]]],[[[2,4],6],[[1,3],7]]]
[6,2]
[[[[5,5],4],0],[[[2,8],[0,1]],[6,[4,5]]]]
[[6,[[8,0],[4,7]]],[[[5,8],8],[[3,9],[4,4]]]]
[[5,[[4,7],8]],[7,1]]
[9,[[[6,8],[6,6]],[[9,3],9]]]
[[6,[[2,1],3]],[[[9,1],8],[8,[5,3]]]]
[[[[3,3],[1,3]],[[6,6],5]],[[4,[6,0]],[[9,7],4]]]
[[[5,7],[[0,3],9]],[[6,9],[[6,0],[6,4]]]]
[[4,[[9,6],[3,9]]],[[[9,3],2],6]]
[[[[1,3],[4,2]],1],3]
[[[[2,9],6],[[0,9],[0,3]]],[[[3,6],5],9]]
[[9,5],[[7,2],[9,[5,0]]]]
[[[4,[4,1]],0],2]
[[[2,[5,7]],[8,2]],[[[1,8],[6,7]],5]]
[1,[[[6,7],[5,4]],[[3,4],4]]]
[0,[[7,4],1]]
[[4,[[1,4],2]],[[[9,9],6],8]]
[7,[[[7,2],9],5]]
[3,6]
[[[[4,4],2],[8,[6,5]]],[9,[4,0]]]
[[4,[6,8]],[[[6,7],[8,8]],[[9,1],9]]]
[2,[0,4]]
[[[1,5],[7,[6,2]]],[[[1,1],3],[4,[5,7]]]]
[[[[0,7],[5,4]],[[6,4],4]],[[[2,3],[4,6]],[[8,5],6]]]
[[1,[[3,8],[1,3]]],[[4,[8,2]],[5,3]]]
[[[[3,5],6],[[1,3],[8,3]]],[[8,[0,5]],6]]
[9,[2,[[1,3],1]]]
[[[1,[7,5]],6],5]
[[[[7,0],0],1],[7,1]]
[[9,[1,7]],[[[3,6],0],[[8,1],1]]]
[[[[9,1],1],[8,[0,4]]],[[9,0],[8,7]]]
[1,[[[9,1],[3,7]],[[7,0],[5,6]]]]
[[[[0,0],[5,2]],[3,2]],[7,5]]
[[8,[[4,3],6]],[0,[[2,7],5]]]
[[[[8,8],[9,9]],[[0,1],[1,0]]],[4,[[4,8],[1,9]]]]
[[[0,[7,3]],4],[6,9]]
[[0,[[2,3],[2,3]]],[[3,5],[3,6]]]
[[[0,3],[4,5]],8]
[0,[[[0,4],4],8]]
[[[[5,7],[0,9]],[[5,6],[2,6]]],[[[5,5],[4,6]],8]]
[[[6,[6,5]],[[0,8],[2,9]]],[[[9,3],[3,9]],[[5,2],3]]]
[[6,[[5,2],[2,8]]],[7,[[7,5],[5,1]]]]
[[2,[8,2]],[[[9,9],[0,4]],[[8,5],[8,8]]]]
[[[[4,2],[7,4]],[[0,9],[8,6]]],[[[6,6],8],[[8,8],5]]]
[[[[6,3],0],[7,9]],0]
[8,[3,[6,0]]]
[[[[8,5],6],[8,4]],[[[9,7],[4,9]],4]]
[[7,[[8,0],0]],4]
[[[1,1],5],[6,[3,[6,3]]]]
[[[0,[0,0]],1],[[3,[1,1]],[1,0]]]
[[[[8,5],6],[3,7]],[[9,6],[5,7]]]
[[0,[[3,6],[3,9]]],7]
[[[3,3],8],[[0,2],[[2,6],1]]]
[1,9]
[6,[3,[[1,1],5]]]
[[[0,1],[4,0]],[[9,3],[6,[4,1]]]]
[[8,8],[[1,7],[9,[1,7]]]]
[[7,[2,8]],[[8,8],[[2,8],2]]]
[[8,[[3,6],5]],[[[2,5],[9,1]],3]]
[[[8,[3,1]],4],[3,1]]
[[[[2,6],3],[[0,8],6]],[[1,[3,1]],[[2,1],[0,6]]]]
[[[[4,2],2],[8,[5,4]]],[[[8,7],[6,4]],[1,[5,1]]]]
[[7,[[4,5],[0,7]]],5]
[[2,[5,[5,2]]],[[2,3],[[5,6],[5,0]]]]
[[[[7,4],[1,4]],[0,[2,0]]],[[[5,3],1],8]]
[5,[[[1,9],[2,1]],[[2,1],[9,5]]]]
[5,[[[7,4],[6,8]],[[7,7],9]]]
[1,[[3,[9,5]],[[8,5],1]]]
[[[6,[8,6]],[6,[9,3]]],5]
[[3,[5,4]],[[[2,8],[1,8]],5]]
[[[1,9],[9,5]],[[[1,7],[5,1]],7]]
[8,[5,[0,2]]]
[[[6,6],9],[2,[8,[7,8]]]]
[[[6,0],4],[[[1,9],1],0]]
[[[[2,0],4],[7,0]],[[[8,4],[1,8]],[[6,7],6]]]
[[[7,4],[[0,2],[9,0]]],5]
[[9,6],[[8,2],[5,3]]]
[[[[3,4],[5,0]],[8,6]],2]
[[[[7,3],1],4],[[[5,5],8],[[4,7],[4,9]]]]
[[4,[8,1]],[[[1,4],9],[4,[1,2]]]]
[[[8,[3,2]],[5,[7,3]]],[[3,[9,8]],[7,[2,4]]]]
[[0,[[0,3],[5,4]]],[7,[4,7]]]
[[3,4],[[0,5],[[9,4],3]]]
[[[[4,9],[1,2]],[[0,0],[1,6]]],[[5,6],[[8,4],[5,7]]]]
[[[[5,6],8],[[2,8],4]],[[5,[4,3]],[[9,6],[7,2]]]]
[[[2,[1,7]],6],[[2,[3,5]],[0,7]]]
[1,6]
[[[[0,0],[8,8]],[9,[8,2]]],6]
[[9,[8,2]],[8,6]]
[[4,6],[[[5,4],[0,8]],[[1,8],[7,3]]]]
[6,[3,[5,[9,5]]]]
[[4,[0,6]],[[[8,7],[6,0]],8]]
[[[[4,2],8],9],[[[4,1],[4,6]],[[0,7],[3,3]]]]
[[[[4,5],[9,6]],[7,[8,0]]],[[2,[9,9]],[8,[0,8]]]]
[[[5,7],0],[[7,[2,5]],[8,[6,7]]]]
[[4,[[0,2],[3,6]]],[[[3,8],[0,8]],9]]`;
const demo18 = ``;
type Pair = [number | Pair, number | Pair];
const parseStr = (source: string) => {
  const lines = source.trim().replace("+", "").split("\n");
  const pairs: Pair[] = lines.map((source) => JSON.parse(source));
  return pairs;
};
const isPair = (p: any): p is Pair => Array.isArray(p);

const depthFirstSearchLeft = (
  pair: Pair,
  within: Pair,
  processor: (pair: Pair, within: Pair) => boolean
): boolean => {
  let temp = processor(pair, within);
  if (!temp && isPair(pair[0]))
    temp = depthFirstSearchLeft(pair[0], within, processor);
  if (!temp && isPair(pair[1]))
    temp = depthFirstSearchLeft(pair[1], within, processor);
  return temp;
};

const magnitude = ([first, second]: Pair): number => {
  return (
    3 * (isPair(first) ? magnitude(first) : first) +
    2 * (isPair(second) ? magnitude(second) : second)
  );
};
const depth = (of: Pair, within: Pair, baseDepth = 0): number => {
  //Traverse within to find the pair?
  if (of === within) return baseDepth;
  if (!isPair(within)) return 0;
  const ret = Math.max(
    (isPair(within[0]) && depth(of, within[0], baseDepth + 1)) || 0,
    (isPair(within[1]) && depth(of, within[1], baseDepth + 1)) || 0
  );
  return ret;
};
const getParent = (of: Pair, within: Pair): Pair | undefined => {
  if (within.find((p) => p === of)) return within;
  if (!isPair(within[0]) && !isPair(within[1])) return undefined;
  const foundParent = ((isPair(within[0]) && getParent(of, within[0])) ||
    (isPair(within[1]) && getParent(of, within[1]))) as Pair;
  if (foundParent) return foundParent;
};
const getRightMostDescendant = (of: Pair): Pair => {
  if (!isPair(of[1])) return of;
  return getRightMostDescendant(of[1]);
};
const getLeftNeighbor = (of: Pair, within: Pair): Pair => {
  const parent = getParent(of, within);
  if (!parent) throw new Error("No parent");
  if (parent[1] === of) {
    if (isPair(parent[0])) return getRightMostDescendant(parent[0]);
    else return parent;
  } else return getLeftNeighbor(parent, within);
};
const getLeftMostDescendant = (of: Pair): Pair => {
  if (!isPair(of[0])) return of;
  return getLeftMostDescendant(of[0]);
};
const getRightNeighbor = (of: Pair, within: Pair): Pair => {
  const parent = getParent(of, within);
  if (!parent) throw new Error("No parent");
  if (parent[0] === of) {
    if (isPair(parent[1])) return getLeftMostDescendant(parent[1]);
    else return parent;
  }
  // else if (parent[1] === of) return parent;
  else return getRightNeighbor(parent, within);
};
const explode = (pair: Pair, within: Pair) => {
  try {
    const leftNeighbor = getLeftNeighbor(pair, within);
    if (isPair(leftNeighbor[1])) {
      (leftNeighbor[0] as number) += pair[0] as number;
    } else {
      (leftNeighbor[1] as number) += pair[0] as number;
    }
  } catch (e) {}
  try {
    const rightNeighbor = getRightNeighbor(pair, within);
    if (isPair(rightNeighbor[0])) {
      (rightNeighbor[1] as number) += pair[1] as number;
    } else {
      (rightNeighbor[0] as number) += pair[1] as number;
    }
  } catch (e) {}
  const parent = getParent(pair, within);
  if (!parent) throw new Error("Explode could not find a parent");
  if (parent[0] === pair) parent[0] = 0;
  else if (parent[1] === pair) parent[1] = 0;
};
const split = (pair: Pair) => {
  if (!isPair(pair[0]) && pair[0] > 9) {
    pair[0] = [Math.floor(pair[0] / 2), Math.ceil(pair[0] / 2)];
  } else if (!isPair(pair[1]) && pair[1] > 9) {
    pair[1] = [Math.floor(pair[1] / 2), Math.ceil(pair[1] / 2)];
  }
};
const shouldSplit = (pair: Pair, within: Pair) => {
  if (!isPair(pair[0]) && pair[0] > 9) {
    split(pair);
    return true;
  } else if (!isPair(pair[1]) && pair[1] > 9) {
    //Hang on, should I look lower? I think so
    if (
      !isPair(pair[0]) ||
      !depthFirstSearchLeft(pair[0], within, shouldSplit)
    ) {
      split(pair);
    }
    return true;
  }
  return false;
};
const shouldExplode = (pair: Pair, within: Pair) => {
  if (depth(pair, within) > 3 && !isPair(pair[0]) && !isPair(pair[1])) {
    explode(pair, within);
    return true;
  }
  return false;
};
const reduce = (pair: Pair) => {
  let doContinue = true;
  while (doContinue) {
    if (depthFirstSearchLeft(pair, pair, shouldExplode)) continue;
    if (depthFirstSearchLeft(pair, pair, shouldSplit)) continue;
    doContinue = false;
  }
  return pair;
};
const getSum = (addend1: Pair, addend2: Pair) => reduce([addend1, addend2]);

const getSumTotal = (input: string) => {
  let [first, ...pairs] = parseStr(input);
  const total = pairs.reduce((a: Pair, b) => getSum(a, b), first);
  return magnitude(total);
};
console.time("Part 1");
console.log("Part 1", getSumTotal(data18));
console.timeEnd("Part 1");
const getBiggestMagnitude = (input: string) => {
  let pairs = parseStr(input);
  const allCombinations = pairs.map((pair, _, arr) =>
    arr
      .filter((p) => p !== pair)
      .map((p) => ({
        x: pair,
        y: p,
        sum: getSum(
          JSON.parse(JSON.stringify(pair)),
          JSON.parse(JSON.stringify(p))
        ),
      }))
  );
  return Math.max(
    ...allCombinations
      .flat()
      .sort(({ sum: sum1 }, { sum: sum2 }) => magnitude(sum2) - magnitude(sum1))
      .map(({ x, y, sum }) => magnitude(sum))
  );
};
console.time("Part 2");
console.log("Part 2", getBiggestMagnitude(data18));
console.timeEnd("Part 2");
